<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Curso de NestJS Back End</title>
  <link rel="stylesheet" href="css/styles.css" />
</head>

<body>
  <h1>Curso de Nest JS V11.0.14 for BackEnd</h1>
  <h2>Indice Tematico</h2>
  <ul>
    <li><a href="cursoNestJS.html#referencia">Referencias</a></li>
    <li><a href="cursoNestJS.html#instalacion">Instalacion iniciales</a></li>
    <li><a href="cursoNestJS.html#estructura">estructura </a></li>
    <li><a href="cursoNestJS.html#modulos">modulos </a></li>
    <li><a href="cursoNestJS.html#controller">controller </a></li>
    <li><a href="cursoNestJS.html#service">service </a></li>
    <li><a href="cursoNestJS.html#https">https </a></li>
    <li><a href="cursoNestJS.html#response">response </a></li>
    <li><a href="cursoNestJS.html#requesBody">reques Body </a></li>
    <li><a href="cursoNestJS.html#params">params</a></li>
    <li><a href="cursoNestJS.html#dto">dto </a></li>
    <li><a href="cursoNestJS.html#validaciones">validaciones en el dto </a></li>
    <li><a href="cursoNestJS.html#pipeline">pipe line</a></li>
    <li><a href="cursoNestJS.html#guards">guards</a></li>
    <li><a href="cursoNestJS.html#database">base de datos </a></li>
    <li><a href="cursoNestJS.html#backup">backup </a></li>
    <li><a href="cursoNestJS.html#convenciones">convenciones en base de datos </a></li>
    <li><a href="cursoNestJS.html#sgbd">Sistema de Gestin de Base de Datos (SGBD) </a></li>
    <li><a href="cursoNestJS.html#prisma-install">prisma ORM </a></li>
    <li><a href="cursoNestJS.html#prisma-modelo">prisma Modelo </a></li>
  </ul>


  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="referencia">Referencias</h2>
  <article>
    pagina de documentacion oficial <a href="https://docs.nestjs.com/" target="_blank"
      rel="noopener noreferrer">NestJS</a> <br>
    curso de nestJS por Fazt <a href="https://www.youtube.com/watch?v=wsqcg5ZtUMM" target="_blank"
      rel="noopener noreferrer">curso por Fazt</a> <br>
    curso de NestJS por codrr <a href="https://www.youtube.com/watch?v=X-59-aXgFH4&list=PLergODdA95kfcSoXqZZ-IDImO6YaQLYlG" target="_blank" rel="noopener noreferrer">curso nestJs por codrr</a> <br>
    CRUD Nest con Prima <a href="https://www.youtube.com/watch?v=vUcNydH1tz0" target="_blank" rel="noopener noreferrer">Nest CRUD con prisma por Fazt</a> <br>
    plantilla recomedada para empezar un proyecto nuevo de nestJS <a href="https://www.youtube.com/watch?v=l--D8yslyUk" target="_blank" rel="noopener noreferrer">plantilla</a> <br>
    <a href="https://www.youtube.com/watch?v=0OnSAqiuUKc&list=PLCKuOXG0bPi2DJQIRNwOIUJ_vO3l5s1b-" target="_blank" rel="noopener noreferrer">NestJs por Fernado Herrera</a> <br>
    Tambien enconcre otro del mismo autora <a href="https://www.youtube.com/watch?v=w9TSbbhMsxo&list=PLCKuOXG0bPi1_cUC7-MDJnXChVLqJydBE" target="_blank" rel="noopener noreferrer">NestJs + graphql</a> <br>
    autonteticacion , JWT y Prisma<a href="https://www.youtube.com/watch?v=AtTBylnIocw" target="_blank" rel="noopener noreferrer">programacion ya</a> <br>
    curso de nestJS con TypeORM <a href="https://www.youtube.com/watch?v=Z6G7mCAeXoE" target="_blank" rel="noopener noreferrer">Nest con TypeORM por Bluuweb</a> <br>
    <a href="https://www.youtube.com/watch?v=RWUmlsdZ1e4&list=PLPl81lqbj-4LqA6sXRETXUg4uNkYG4aUc" target="_blank" rel="noopener noreferrer">Nest api rest con typeORM por Blueweb</a><br>
    <a href="https://www.youtube.com/watch?v=w9TSbbhMsxo&list=PLCKuOXG0bPi1_cUC7-MDJnXChVLqJydBE&index=1" target="_blank" rel="noopener noreferrer">Nest + graphQl por Fernando Herrera</a> <br>
    <a href="https://www.youtube.com/watch?v=HLoTP_ZBEY4" target="_blank" rel="noopener noreferrer">NestJS - Episodio I: Creando una API Rest + PostgreSQL + Prisma + Swagge por Medieval script</a> <br>
    <a href="https://www.youtube.com/watch?v=VvrVPrifRUw" target="_blank" rel="noopener noreferrer">Prisma 7</a> <br>
    

  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="instalacion">Instalacion Inicial</h2>
  <article>
    empezaremos intalando el modulo a nivel general
    <pre>
      <code>
         npm i -g @nestjs/cli
      </code>
    </pre>
    creamo el proyecto de NestJS llamado <strong>api-nest</strong>
    <pre>
      <code>
        nest new api-nest
      </code>
    </pre>
    entramo al proyecto, instalamos dependencias y ejecutamos el projecto
    <pre>
      <code>
        cd api-nest 
        npm install
        npm run start
      </code>
    </pre>
    en produccion se ejecuta con <strong>npm run start</strong> <br>
    pero en desarrollo se ejectua con <strong>npm run start:dev </strong> <br><br>

    Una vez instalado podemos ver los comando que nos permite trabajar, escribiendo <strong>nest</strong> <br>
    <strong>new n</strong> genera un nuevo projecto de nest <br>
    <strong>build</strong> compila nuestra aplicacion de nest <br>
    <strong>start</strong> ejecuta e inicializa nuestra aplicacion <br>
    <strong>info i</strong> muestra informacion <br>
    <strong>add</strong> adiciona una libreria al proyecto <br>
    <strong>generate g</strong> genera un nuevo elemento nest <br>

    <pre>
      <code>
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ name          â”‚ alias       â”‚ description                                  â”‚
        â”‚ application   â”‚ application â”‚ Generate a new application workspace         â”‚
        â”‚ class         â”‚ cl          â”‚ Generate a new class                         â”‚
        â”‚ configuration â”‚ config      â”‚ Generate a CLI configuration file            â”‚
        â”‚ controller    â”‚ co          â”‚ Generate a controller declaration            â”‚
        â”‚ decorator     â”‚ d           â”‚ Generate a custom decorator                  â”‚
        â”‚ filter        â”‚ f           â”‚ Generate a filter declaration                â”‚
        â”‚ gateway       â”‚ ga          â”‚ Generate a gateway declaration               â”‚
        â”‚ guard         â”‚ gu          â”‚ Generate a guard declaration                 â”‚
        â”‚ interceptor   â”‚ itc         â”‚ Generate an interceptor declaration          â”‚
        â”‚ interface     â”‚ itf         â”‚ Generate an interface                        â”‚
        â”‚ library       â”‚ lib         â”‚ Generate a new library within a monorepo     â”‚
        â”‚ middleware    â”‚ mi          â”‚ Generate a middleware declaration            â”‚
        â”‚ module        â”‚ mo          â”‚ Generate a module declaration                â”‚
        â”‚ pipe          â”‚ pi          â”‚ Generate a pipe declaration                  â”‚
        â”‚ provider      â”‚ pr          â”‚ Generate a provider declaration              â”‚
        â”‚ resolver      â”‚ r           â”‚ Generate a GraphQL resolver declaration      â”‚
        â”‚ resource      â”‚ res         â”‚ Generate a new CRUD resource                 â”‚
        â”‚ service       â”‚ s           â”‚ Generate a service declaration               â”‚
        â”‚ sub-app       â”‚ app         â”‚ Generate a new application within a monorepo â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

      </code>  
    </pre>


  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="estructura">Estructura Inicial</h2>
  <article>
    Estructura inicial esta compueta por <strong>main.ts</strong>, y <strong>app.controller.ts, app.service.ts,
      app.module.ts</strong> con los
    siguientes codigos : <br>
    <strong>main.ts</strong>
    <pre>
      <code>
        import { NestFactory } from '@nestjs/core';
        import { AppModule } from './app.module';
        
        async function bootstrap() {
          const app = await NestFactory.create(AppModule);
          await app.listen(process.env.PORT ?? 3000);
        }
        bootstrap();
        
      </code>
    </pre>
    <strong>app.module.ts</strong>
    <pre>
      <code>
        import { Module } from '@nestjs/common';
        import { AppController } from './app.controller';
        import { AppService } from './app.service';
        
        @Module({
          imports: [],
          controllers: [AppController],
          providers: [AppService],
        })
        export class AppModule {}

      </code>
    </pre>

    <strong>app.controller.ts</strong>
    <pre>
      <code>
        import { Controller, Get } from '@nestjs/common';
        import { AppService } from './app.service';
        
        @Controller()
        export class AppController {
          constructor(private readonly appService: AppService) {}
        
          @Get()
          getHello(): string {
            return this.appService.getHello();
          }
        }
        
      </code>
    </pre>
    <strong>app.service.ts</strong>
    <pre>
      <code>
        import { Injectable } from '@nestjs/common';
        
        @Injectable()
        export class AppService {
          getHello(): string {
            return 'Hello World! welcome NestJS';
          }
        }

      </code>
    </pre>
    <strong>Nota</strong> <br>
    si eliminamos el controller y el service y nos quedamos solamente con el module quedaria de la siguiente forma: <br>
    <pre>
      <code>
        import { Module } from '@nestjs/common';
        
        @Module({
          imports: [],
          controllers: [AppController],
          providers: [AppService],
        })
        export class AppModule {}

      </code>
    </pre>
    al ejecutarlo con <strong>npm run start:dev</strong> nos mostraria el siguiente error: <br>
    status: 404 porque no encuenta la pagina que debe ser llamanda desde el controlador. <br>

  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="modulos">modulos</h2>
  <article>
    Los modulos son como contenederos que agrupan componentes realacionados como: <br>
    controladores, servicios, proveedores, etc bajo el mismo contexto. <br>
    ayuda al encansulamiento porque cada modulo es indepediente y organiza el codigo, permite <br>
    la reutilizacion porque cada modulo puede exportar cierto servicios y componente evitando <br>
    la duplicacion logica del codigo. <br>
    permite la inyeccion de dependencia, permite compartir entre modulos. <br>
    Todo proyecto de nest tiene un <strong>AppModule</strong> (modulo raiz) que sirve como punto <br>
    de entrada y donde se importa los demas modulos: <br>
    <strong>Ejemplo basico de AppModule</strong>
    <pre>
      <code>
        import { Module } from '@nestjs/common';
        import { UsersController } from './users.controller';
        import { UsersService } from './users.service';
        
        @Module({
          controllers: [UsersController],
          providers: [UsersService],
          exports: [UsersService], // permite que otros mÃ³dulos usen este servicio
        })
        export class UsersModule {}
        
        En este ejemplo:
        
        UsersController maneja las rutas relacionadas con usuarios.
        UsersService contiene la lÃ³gica de negocio.
        UsersModule agrupa todo y puede compartir el servicio con otros mÃ³dulos.
        
        ğŸ‘‰ En resumen: los mÃ³dulos en NestJS son la columna vertebral de la arquitectura, permiten organizar, encapsular y escalar aplicaciones de manera limpia y modular.
      </code>
    </pre>
    Por convencion se recomienda que cada modulo exista en un carpeta idependiente en minuscula y en plural osea: <br>
    a excepcion de <strong>app</strong> que no debe estar en carpeta si en la parte externa de la aplicacion. <br>

    <pre>
      <code>
        users/
        orders/
        products/
        invoices/
        roles/
        permissions/

      </code>
    </pre>
    exception en singular por ser modulos conceptuales y no representan <strong>CRUD</strong> de la aplicacion
    <pre>
      <code>
        auth/
        config/
        common/
        health/

      </code>
    </pre>
    empezaremos creando una subcarpeta <strong>tasks</strong> donde crearemos nuestro modulo de tareas. <br>
    dentro de la carpeta <strong>scr</strong> <br>
    ejecutamos el comando : <br>
    <pre>
      <code>
        
        $ nest generate --help
        Usage: nest generate|g [options] <schematic> [name] [path]
        
        Generate a Nest element.
          Schematics available on @nestjs/schematics collection:
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ name          â”‚ alias       â”‚ description                                  â”‚
            â”‚ application   â”‚ application â”‚ Generate a new application workspace         â”‚
            â”‚ class         â”‚ cl          â”‚ Generate a new class                         â”‚
            â”‚ configuration â”‚ config      â”‚ Generate a CLI configuration file            â”‚
            â”‚ controller    â”‚ co          â”‚ Generate a controller declaration            â”‚
            â”‚ decorator     â”‚ d           â”‚ Generate a custom decorator                  â”‚
            â”‚ filter        â”‚ f           â”‚ Generate a filter declaration                â”‚
            â”‚ gateway       â”‚ ga          â”‚ Generate a gateway declaration               â”‚
            â”‚ guard         â”‚ gu          â”‚ Generate a guard declaration                 â”‚
            â”‚ interceptor   â”‚ itc         â”‚ Generate an interceptor declaration          â”‚
            â”‚ interface     â”‚ itf         â”‚ Generate an interface                        â”‚
            â”‚ library       â”‚ lib         â”‚ Generate a new library within a monorepo     â”‚
            â”‚ middleware    â”‚ mi          â”‚ Generate a middleware declaration            â”‚
            â”‚ module        â”‚ mo          â”‚ Generate a module declaration                â”‚
            â”‚ pipe          â”‚ pi          â”‚ Generate a pipe declaration                  â”‚
            â”‚ provider      â”‚ pr          â”‚ Generate a provider declaration              â”‚
            â”‚ resolver      â”‚ r           â”‚ Generate a GraphQL resolver declaration      â”‚
            â”‚ resource      â”‚ res         â”‚ Generate a new CRUD resource                 â”‚
            â”‚ service       â”‚ s           â”‚ Generate a service declaration               â”‚
            â”‚ sub-app       â”‚ app         â”‚ Generate a new application within a monorepo â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        Options:
          -d, --dry-run                      Report actions that would be taken without writing out results.
          -p, --project [project]            Project in which to generate files.
          --flat                             Enforce flat structure of generated element.
          --no-flat                          Enforce that directories are generated.
          --spec                             Enforce spec files generation. (default: true)
          --spec-file-suffix [suffix]        Use a custom suffix for spec files.
          --skip-import                      Skip importing (default: false)
          --no-spec                          Disable spec files generation.
          -c, --collection [collectionName]  Schematics collection to use.
          -h, --help                         Output usage information.
      </code>
    </pre>
    el codigo de nuestro modulo quedaria: <br>
    <pre>
      <code>
        import { Module } from "@nestjs/common";
        
        @Module({})
        export class TaskModule{
        
        }        
      </code>
    </pre>
    ahora nuestro modulo TaskModule tenemos que importarlo desde app.module.ts : <br>
    <pre>
      <code>
        import { Module } from '@nestjs/common';
        import { AppController } from './app.controller';
        import { AppService } from './app.service';
        import { TaskModule } from './tasks/tasks.module';
        
        @Module({
          imports: [TaskModule],
          controllers: [AppController],
          providers: [AppService],
        })
        export class AppModule {}


      </code>
    </pre>
    por ejemplo si queremos crear un modulo <strong>project</strong> escribimos:
    <pre>
      <code>
        nest g mo project
      </code>
    </pre>
    y aumaticamente crea a carpeta <strong>project</strong> y crea project.module.ts, <tr>
      ademas dentro de app.module.ts import el modulo creado </tr>

  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="controller">controller</h2>
  <article>
    nuestro controllador base llamado <strong>tasks.controller.ts</strong> seria asi: <br>
    <pre>
      <code>
        import { Controller } from "@nestjs/common";
        
        @Controller({})
        export class TaskController{
        
        }        
      </code>
    </pre>
    Notamos que el codigo es muy parecido al codigo de modulo, simplemente es una clase <br>
    que se exporta y utiliza un decorador llamado controller, el cual debe ser importador inicialmente. <br>
    Ahora este controller para ser utilizado debe ser agregado en nuesto <strong>task.module.controller.ts</strong> <br>
    quedando de la siguiente forma: <br>
    <pre>
      <code>
        import { Module } from "@nestjs/common";
        import { TaskController } from "./tasks.controller";
        
        @Module({controllers:[TaskController]})
        export class TaskModule{
        
        }        
        
      </code>  
      dentro del objeto vacio que colocamos en nuestro modulo es donde se debe configurar el controlador, <br>
      que vamos a utilizar <strong>{controllers:[TaskController]}</strong> y previamente debe ser importado
    </pre>
    ahora en nuestro controller es donde van a ir todas las rutas que son llamadas en los endpoint, <br>
    por ahora devolveremos un simple mensaje de texto en nuestra ruta tasks, quedando asi: <br>
    <pre>
      <code>
        import { Controller, Get } from "@nestjs/common";
        
        @Controller({})
        export class TaskController{
            @Get('/tasks')
            getAllTasks(){
                return 'Obteniendo todas las tareas'
            }
        }
        
      </code>
    </pre>
    ahora vamos hacer lo mismo pero de manera automatico en nuesta carpeta de prueba que la <br>
    creamos de forma automatica si: <br>
    <pre>
      <code>
        nest g co prueba
      </code>
    </pre>
    con esto le decimos que nos cree un controlador dentro de la carpeta prueba y el <br>
    hace todos los import y configuracion que hiciemos manual <br>
    pero tambien nos genero un archivo de testeo interno si no lo queremos debemos escribir:
    <pre>
      <code>
        nest g co prueba --no-spec
      </code>
    </pre>

  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="service">service</h2>
  <article>
    dentro del service creamos la funcione que ejecuta toda la logica, los <strong>controler</strong>, simplemente <br>
    muestra la ruta que debemos retornar, pero la logica debe estar en los service. <br>
    <pre>
      <code>
        import { Injectable } from "@nestjs/common";
        
        @Injectable()
        export class TaskService{
        
        }        

      </code>
    </pre>
    podemos notar que la clase es parecida a la de modulo y a la de controladores, pero en este caso, <br>
    se llama <strong>injectable</strong>, y en el decorador tampoco hay que inicializar un objeto vacio. <br>
    ahora dentro de la clase crearemos la funcion que me va a retorna un array : <br>
    <pre>
    <code>
      import { Injectable } from "@nestjs/common";
      
      @Injectable()
      export class TaskService{
      
          getTasks(){
              return ["task1","task2","tasks3"]
          }
      }
      
    </code>
  </pre>
    ahora nuestro controller debe llamar a nuestro service y necesitamos crear un contructor el codigo es el <br>
    siguiente: <br>
  <pre>
    <code>
      import { Controller, Get } from "@nestjs/common";
      import { TasksService } from "./tasks.service";
      
      @Controller({})
      export class TasksController {
          tasksService: TasksService;
      
          constructor(tasksService: TasksService) {
              this.tasksService = tasksService;
          }
          @Get('/tasks')
          getAllTasks() {
              return this.tasksService.getTasks();
          }
      }      
      
    </code>
  </pre>
    por ultimo para nuestro controlador sepa que va a utilizar un service lo debemos expecificar en el modulo: <br>
  <pre>
    <code>
      import { Module } from "@nestjs/common";
      import { TaskController } from "./tasks.controller";
      import { TasksService } from "./tasks.service";
      
      
      @Module({controllers:[TaskController], providers:[TasksService]})
      export class TaskModule{
      
      }
      
    </code>  

  </pre>
  como podemos notar nuestro codigo de controller. esta algo verboso se puede mejorar asÃ­:
  <pre>
    <code>
      import { Controller, Get } from "@nestjs/common";
      import { TasksService } from "./tasks.service";
      
      @Controller('tasks')
      export class TasksController {
      
          constructor(private readonly tasksService: TasksService) {

          }
          @Get()
          getAllTasks() {
              return this.tasksService.getTasks();
          }
      }
      
    </code>

  </pre>
  <strong>Nota de mejoria del codigo</strong> <br>
  el controlador no debe tener un objeto vacio, sino la ruta principal del controlador <strong>tasks</strong>, esta ruta hay que quitarla, <br>
  del <strong>get()</strong> porque tendriamos que escribirla por cada funcion que hagamos. <br>
  con respecto al codigo anterior se cambio dentro del contructor una variable local quedando asÃ­: <br>
  <strong>private readonly tasksService: TasksService</strong> y no hay inicializar nada ni que recibir el paso de una variable a 
  otra local. este concepto se llama <strong>injection de dependencia simplificado</strong><br>

  si queremos crear el servicio de forma automatica en nuestra carpeta de prueba seria:
  <pre>
    <code>
      nest g s prueba --no-spec
    </code>
  </pre>
  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="https">https</h2>
  <article>
    los https se utilizan para manejar los diferentes metodos del CRUD <br>
    la logica de negocio del service quedaria asi:
    <pre>
      <code>
        import { Injectable } from "@nestjs/common";
        
        @Injectable()
        export class TasksService {
        
            getTasks() {
                return ["task1", "task2", "task3"]
            }
            
            createTasks(){
                return "create tasks" ;
            }
        
            updateTasks(){
                return "editar tarea";
            }
        
            deleteTasks(){
                return "eliminar tareas" ;
            }
        
            updateTasksState(){
                return "actualizando estado" ;
            }
        
        
        }
        
      </code>
    </pre>
    y el controlador que llama al servicio es donde vamos a importar los metodos get, put, post, delete, patch para <br>
    luego llamar a nuestro servicio, el codigo del cotrolador seria : <br>
    <pre>
      <code>
        import { Controller, Get, Post,Put,Delete,Patch } from "@nestjs/common";
        import { TasksService } from "./tasks.service";
        
        @Controller('tasks')
        export class TasksController {
        
            constructor(private readonly tasksService: TasksService) {
        
            }
        
            @Get()
            getAllTasks() {
                return this.tasksService.getTasks();
            }
        
            @Post()
            createTasks(){
                return this.tasksService.createTasks();
            }
        
            @Put()
            updateTasks(){
                return this.tasksService.updateTasks();
            }
        
            @Delete()
            deleteTasks(){
                return this.tasksService.deleteTasks();
            }
        
            @Patch()
            updateTasksState(){
                return this.tasksService.updateTasksState();
            }
        }
        
      </code>
    </pre>

  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="response">response</h2>
  <article>
    En NestJS, Response normalmente se refiere al objeto de respuesta HTTP que proviene de Express (o Fastify, segÃºn el adaptador que uses). <br>
    NestJS estÃ¡ construido sobre Express (por defecto) o Fastify. <br>
    Cuando inyectas @Res() en un controlador, lo que recibes es el objeto Response de Express/Fastify. <br>
    Este objeto te permite controlar manualmente la respuesta HTTP: enviar JSON, redirigir, establecer cabeceras, cookies, etc. <br>
    un ejemplo con express seria: <br>
    <pre>
      <code>
        import { Controller, Get, Res } from '@nestjs/common';
        import { Response } from 'express';
        
        @Controller('tasks')
        export class TasksController {
          @Get()
          getTasks(@Res() res: Response) {
            const tasks = [{ id: 1, name: 'Test task' }];
            res.status(200).json(tasks);
          }
        }
        
        
      </code>
    </pre>
    pero segun las mejores practicas debe ser y NestJS se encarga de la conversion de json : <br>
    <pre>
      <code>
        @Get()
        getTasks() {
          return [{ id: 1, name: 'Test task' }];
        }
        
        
      </code>
    </pre>
    Para JSON y respuestas normales, mejor retornar directamente y dejar que NestJS maneje todo. <br>
    Para descargas, redirecciones o streams, usa @Res() porque necesitas control manual. <br>
    <strong>ejemplo de descaga</strong>  <br>
    <pre>
      <code>
        import { Controller, Get, Res } from '@nestjs/common';
        import { Response } from 'express';
        import { join } from 'path';
        
        @Controller('files')
        export class FilesController {
          @Get('download')
          downloadFile(@Res() res: Response) {
            const filePath = join(__dirname, '..', 'assets', 'example.pdf');
            res.download(filePath, 'mi-archivo.pdf'); 
          }
        }
        
        
      </code>
    </pre>
  </article>


  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="requesBody">Reques Body</h2>
  <article>
    En NestJS, el request body es el contenido que envÃ­a el cliente dentro de una peticiÃ³n HTTP <br>
    (normalmente en mÃ©todos POST, PUT o PATCH). Es la parte del mensaje donde se transmiten los datos que <br>
    quieres procesar en tu servidor, por ejemplo un objeto JSON con informaciÃ³n de una tarea, usuario, producto, etc. <br><br>
    <strong>codigo task.controller.ts</strong> <br>
    <pre>
      <code>
        import { Controller, Get, Post, Put, Delete, Patch, Body } from "@nestjs/common";
        import { TasksService } from "./tasks.service";
        
        @Controller('tasks')
        export class TasksController {
        
            constructor(private readonly tasksService: TasksService) {
        
            }
        
            @Get()
            getAllTasks() {
                return this.tasksService.getTasks();
            }
        
            @Post()
            createTasks(@Body() task: any) {
                return this.tasksService.createTask(task);
            }
        
            @Put()
            updateTasks() {
                return this.tasksService.updateTask();
            }
        
            @Delete()
            deleteTasks() {
                return this.tasksService.deleteTask();
            }
        
            @Patch()
            updateTasksState() {
                return this.tasksService.updateTaskState();
            }
        }        

      </code>
    </pre>
    utilizamos el decorador @Body(), el cual es importado desde @nestjs/common, y lo pasamo como parametro al servicio <br>
    <strong>codigo task.service.ts</strong> <br>
    <pre>
      <code>
        
        import { Injectable } from "@nestjs/common";
        
        export interface Task {
            id: number,
            description: string,
            state: boolean
        }
        
        
        @Injectable()
        export class TasksService {
            private tasks: Task[] = [];
        
            getTasks(): Task[] {
        
                return this.tasks
            }
        
            createTask(task: any) {
                console.log(task);
                this.tasks.push(task);
                return this.tasks;
            }
        
            updateTask() {
                return "editar tarea";
            }
        
            deleteTask() {
                return "eliminar tareas";
            }
        
            updateTaskState() {
                return "actualizando estado";
            }
        }      

      </code>
    </pre>
    ahora separamos la interface en una carpeta independiente<strong>interfaces</strong> y el codigo de tasks.interface.ts : <br>
    <pre>
      <code>
        export interface Task {
            id: number,
            description: string,
            state: boolean
        }
        
      </code>
    </pre>
    ahora nuestro service tiene que importar a la interface que creamos independiente: quedando asi: <br>
    <pre>
      <code>
        import { Injectable } from "@nestjs/common";
        import { Task } from "./interfaces/tasks.interface";
        
        @Injectable()
        export class TasksService {
            private tasks: Task[] = [];
        
            getTasks(): Task[] {
        
                return this.tasks
            }
        
            createTask(task: any) {
                console.log(task);
                this.tasks.push(task);
                return task;
            }
        
            updateTask() {
                return "editar tarea";
            }
        
            deleteTask() {
                return "eliminar tareas";
            }
        
            updateTaskState() {
                return "actualizando estado";
            }
        
        }
        
      </code>
    </pre>
  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="params">Query y params</h2>
  <article>
    como pasamos los parametros dentro de la URL. por ejemlo si yo quiero una ruta asi: <br>
    <pre>
      <code>
        http://localhost:3000/tasks?limit=2        
      </code>
    </pre>
    que nos indica que al consultar las tasks solo quiero que me muestre 2 y no todas las tareas <br>
    <strong>codigo en el controlador</strong> <br>
    <pre>
      <code>
        @Get()
        getAllTasks(@Query() query: any) {
            console.log(query);
            return this.tasksService.getTasks();
        }
        
        
      </code>
    </pre>
    ahora queremos pasarle un parametro osea que la URL se mas asi:
    <pre>
      <code>
        http://localhost:3000/tasks/1        
      </code>
    </pre>
    para que me muestre la tarea 1 o cualquier numero que se pase como parametro. <br>
    <strong>codigo en el controlador</strong>
    <pre>
      <code>
        @Get("/:id")
        getTask(@Param("id") id: string) {
            console.log(id);
            return this.tasksService.getTask(parseInt(id));
    
        }
        
        
      </code>
    </pre>
    y dentro del servicio se recibe el parametro quedando asÃ­:
    <pre>
      <code>
        getTask(id: number): Task | undefined {
            console.log("parametro = ", id)
            const taskFound = this.tasks.find(task => task.id === id)
    
            if (!taskFound) {
               throw new NotFoundException(`Task with id ${id} not found`);
            }
    
            return taskFound;
        }
        
      </code>
    </pre>

  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="dto">dto</h2>
  <article>
    <strong>dto</strong>, son los utilizado para transferir datos entre capas. <br>
    creamos las carpeta <strong>dto</strong> y dentro de ella los archivos <strong>create-task.dto.ts</strong> y para las actualizaciones <br>
    en update-task-dto.ts en la version de recurso genera un clase parcial y hay que tener instalado : <br>
    <pre>
      <code>
        npm install @nestjs/mapped-types
        
      </code>
    </pre>
    <strong>update-task.dto.ts</strong> con los siguientes codigos corrrespondiente:
    <pre>
      <code>
        export class CreateTaskDto {
            id: number
            description: string
            state: boolean
        }

      </code>
    </pre>
    y el codigo de actualizacion seria: <br>
    <pre>
      <code>
        export class UpdateTaskDto {
            description?: string
            state?: boolean
        }
        
        
      </code>
    </pre>
    Notese que el codigo es muy parecido la diferencias seria en que en la actualizacion los campos son opcionales por eso es que se usa el signo <strong>?</strong> <br>

  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="validaciones">validaciones</h2>
  <article>
    En NestJS las validaciones se implementan principalmente con ValidationPipe y las librerÃ­as <strong>class-validator</strong> y 
    <strong>class-transformer</strong>. <br>
    Se definen reglas en los DTOs con decoradores, y el pipe se encarga de verificar automÃ¡ticamente los datos entrantes. <br>
    Para trabajar con las validaciones inicialmente hay que instalar las librerias asi: <br>
    <pre>
      <code>
        npm install class-validator class-transformer
        
        
      </code>
    </pre>
    codigo de validacion dentro del dto de crear tarea: <br>
    <pre>
      <code>
        import { IsBoolean, IsNotEmpty, IsNumber, IsString, MinLength } from "class-validator"
        
        export class CreateTaskDto {
            @IsNumber()
            id: number
        
            @IsString()
            @IsNotEmpty()
            @MinLength(10)
            description: string
        
            @IsBoolean()
            state: boolean
        }

      </code>
    </pre>
    para que la validacion se aplique de forma global hay que importar <strong>ValidationPipe</strong> dentro del <strong>main.ts</strong> <br>
    <pre>
      <code>
        import { NestFactory } from '@nestjs/core';
        import { AppModule } from './app.module';
        import { ValidationPipe } from '@nestjs/common';
        
        async function bootstrap() {
          const app = await NestFactory.create(AppModule);
          app.useGlobalPipes(new ValidationPipe());
          await app.listen(process.env.PORT ?? 3000);
        }
        bootstrap();
        
        
      </code>
    </pre>
  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="pipeline">Pipeline</h2>
  <article>
    Cada peticiÃ³n HTTP pasa por un pipeline de ejecuciÃ³n. <br>
    Este pipeline estÃ¡ compuesto por middlewares, guards, interceptors, pipes y filters. <br>
    Los pipes son una parte clave: sirven para transformar y validar los datos que entran a tu aplicaciÃ³n. <br><br>
    
    Por ejemplo si creamos una funcion <strong>token</strong> que recibe un numero  y retorno otro sumado 10, quedaria asÃ­;
    <pre>
      <code>
        import { Controller, Get, Post, Put, Delete, Patch, Body, Query, Param, ParseIntPipe } from "@nestjs/common";


        @Get('ticket/:num')
        getToken(@Param("num", ParseIntPipe) num: number){
            console.log(num);
            return num+10;
    
        }
            
      </code>
    </pre>
    y para probarlo escribimos: <br>
    <pre>
      <code>
        http://localhost:3000/tasks/ticket/2        
      </code>
    </pre>

  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="guards">Guards </h2>
  <article>
    un Guard es una clase que decide si una peticiÃ³n puede acceder a un controlador o ruta. <br>
    Se usa principalmente para autenticaciÃ³n y autorizaciÃ³n, verificando permisos, roles o condiciones antes de ejecutar el mÃ©todo del controlador <br><br>
    <strong>Ejemplo basico de Guards</strong> <br>
    <pre>
      <code>
        import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
        import { Observable } from 'rxjs';
        
        @Injectable()
        export class AuthGuard implements CanActivate {
          canActivate(
            context: ExecutionContext,
          ): boolean | Promise&lt;boolean> | Observable&lt;boolean> {
            const request = context.switchToHttp().getRequest();
            return request.headers.authorization === 'Bearer miToken';
          }
        }
        
        
      </code>
    </pre>
    <strong>En el controlador del tasks seria:</strong> <br>
    <pre>
      <code>
        import { AuthGuard } from "./guards/auth/auth.guard";
        
        @UseGuards(AuthGuard)
        @Get()
        getAllTasks(@Query() query: any) {
            console.log(query);
            return this.tasksService.getTasks();
        }
        
        
      </code>
    </pre>
    Ejemplo practico validaremos No permitir acceder a un endpoint si el request no tiene el header Authorization o si el token es incorrecto. <br>
    creamos un guards dentro de nuestro endpont de taks con el siguiente comando:
    <pre>
      <code>
        nest g guard tasks/guards/auth
      </code>
    </pre>
    esto genera el siguiente codigo : <br>
    <pre>
      <code>
        import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
        import { Observable } from 'rxjs';
        
        @Injectable()
        export class AuthGuard implements CanActivate {
          canActivate(
            context: ExecutionContext,
          ): boolean | Promise<boolean> | Observable<boolean> {
            return true;
          }
        }
       
        
      </code>
    </pre>
    si desde el navegadora colocamos la direccion : <br>
    <pre>
      <code>
        http://localhost:3000/tasks
        
        {
        message: "Forbidden resource",
        error: "Forbidden",
        statusCode: 403
        }
        
      </code>
    </pre>
    porque no se le ha pasado la utorizacion en el encabezad desde el navegador seria:
    <pre>
      <code>
        http://localhost:3000/tasks \  -H "Authorization: Bearer miToken"
      </code>
    </pre>
  </article>


  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="database">base de datos</h2>
  <article>
    curso de base de datos Postgres en linux para analitica de datos <a
      href="https://www.youtube.com/watch?v=5no6nDBLjSc" target="_blank" rel="noopener noreferrer">postgres en linux por
      camilo suarez</a> <br>
    curso de base de datos por todoCoude <a href="https://www.youtube.com/watch?v=8N4M994IDt8" target="_blank"
      rel="noopener noreferrer">base de datos</a> <br>
    curso de base de datos por SergieCode <a href="https://www.youtube.com/watch?v=Fca_kWJJXvo" target="_blank"
      rel="noopener noreferrer">mysql, postgres, para BackEnd</a>
  </article>

    <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="backup">backup</h2>
  <article>
    para relizar copia de postgresql, lo primero que demos hacerlo en agregarlo en el path para poder ejecutarlo desde cualquier parte: <br>
    <pre>
      <code>
        1. ejecutamos win + R 
        2. escribimos sysdm.cpl
        3. entramos a la pestaÃ±a opciones avanzadas, y despues le damos al boton Variables de entorno
        4. en variables del sistemas buscamos la variable path despues le damos editar y por ulitmo nuevo
        5. agregamos la ruta C:\Program Files\PostgreSQL\16\bin
        6. reiniciamos el computador
      </code>
    </pre>
    ahora el comando para realizar la copia de seguridad es:
    <pre>
      <code>
        pg_dump -U postgres -F c -f mi_proyecto.backup mi_db

        ejmplo:
        pg_dump -U postgres -F c -f supplier_enero_31_2026.backup supplier

      </code>
    </pre>
    y para restaurar la copia es: <br>
    <pre>
      <code>
        pg_restore -U postgres -d nueva_db mi_proyecto.backup

        ejemplo:

        pg_restore -U postgres --clean -d supplier supplier_enero_31_2026.backup

        si quiere que se actulice la base de datos, pero si la base de datos no existe entonce seria:

        pg_restore -U postgres --create -d supplier supplier_enero_31_2026.backup



      </code>
    </pre>
  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="convenciones">convenciones en base de datos</h2>
  <article>
    <strong>convenciones para nombre de tablas y columnas</strong> <br>
    <pre>
      <code>
        Nombres de tablas y columnas:
        
        Usa snake_case (ej: user_account, order_item).
        Siempre en singular para tablas que representan entidades (user, product).
        Evita abreviaturas poco claras.
        
        Esquemas:
        
        Usa esquemas para separar dominios (ej: auth.user, sales.order).
        MantÃ©n un esquema public solo para pruebas o datos comunes.
        Define permisos por esquema para mayor seguridad.
        
        Llaves primarias y forÃ¡neas:
        
        Usa id como PK con tipo BIGSERIAL o UUID.
        Nombra las FK con el patrÃ³n <tabla>_id (ej: user_id).
        
        Ãndices:
        
        Crea Ã­ndices en columnas usadas en WHERE, JOIN y ORDER BY.
        Usa Ã­ndices Ãºnicos para garantizar integridad.
        para los nombres se recomienda idx_<tabla>_<columnas>
        para FK constraints se recomienda fk_<tabla>_<referencia>
        unique se recomienda uq_<tabla>_<campo>
        
        Migraciones:
        Siempre versiona cambios en la base de datos.
        Documenta decisiones de diseÃ±o en cada migraciÃ³n.        

      </code>
    </pre>
    un ejemplo de las esctructura de una base de datos en postgres seria: <br>
    <pre>
      <code>
      </code>
      -- Esquema para autenticaciÃ³n y usuarios
      CREATE SCHEMA auth;
      
      CREATE TABLE auth.user (
          id BIGSERIAL PRIMARY KEY,
          email VARCHAR(255) UNIQUE NOT NULL,
          password_hash TEXT NOT NULL,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
      
      -- Esquema para catÃ¡logo de productos
      CREATE SCHEMA catalog;
      
      CREATE TABLE catalog.product (
          id BIGSERIAL PRIMARY KEY,
          name VARCHAR(150) NOT NULL,
          description TEXT,
          price NUMERIC(10,2) NOT NULL,
          stock INT DEFAULT 0,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
      
      -- Esquema para ventas
      CREATE SCHEMA sales;
      
      CREATE TABLE sales.order (
          id BIGSERIAL PRIMARY KEY,
          user_id BIGINT NOT NULL REFERENCES auth.user(id),
          total NUMERIC(10,2) NOT NULL,
          status VARCHAR(50) DEFAULT 'pending',
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
      
      CREATE TABLE sales.order_item (
          id BIGSERIAL PRIMARY KEY,
          order_id BIGINT NOT NULL REFERENCES sales.order(id),
          product_id BIGINT NOT NULL REFERENCES catalog.product(id),
          quantity INT NOT NULL,
          price NUMERIC(10,2) NOT NULL
      );
      
    </pre>
    <a href="cursoNestJS.html">â«</a>
    <hr />
    <h2 id="sgbd">SGBD Sistema de Gestion de Base de Datos</h2>
    <article>
      Primero que todo hay que entender que Postgres en un sistemas de gestion multi proceso no multihilo. <br>
      esto quiere de decir que el servidor esta escuchando y varios procesos estan corriendo solicitnao informacion,
      <br>
      como una pagina hecha con Next, o un administrador de DB como DBeaver, etc. <br>
      por cada conexion se crea un servicio independiente para el sistema operativo, de tal forma que no interfiere unos
      con los otros, en cambio Mysql <br>
      maneja una sola conexion con multiples hilos (multi-thread). <br>
      ventajas de postgres, si un proceso falla no interfiere con los demas, en cambio en mysql si la conexion falla
      todos los procesos fallan, <br>
      es por eso que postgres nececita mas memoria que mysql. <br><br>
      <pre>
      <code>
        ğŸ’¡ Consejo de DBA: en aplicaciones modernas, para evitar saturar el servidor con demasiados procesos, 
        se recomienda usar un connection pooler como PgBouncer o Pgpool-II, que gestionan las conexiones de manera mÃ¡s eficiente.        
      </code>
    </pre>
      PostgreSQL es un motor cliente-servidor con arquitectura multi-proceso (no multi-thread).
      <pre>
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      | Componente            | FunciÃ³n                              |
      | --------------------- | ------------------------------------ |
      | Postmaster            | Proceso padre, gestiona conexiones   |
      | Backend process       | Un proceso por conexiÃ³n              |
      | Shared Buffers        | CachÃ© de datos en memoria            |
      | WAL (Write-Ahead Log) | Garantiza durabilidad                |
      | Autovacuum            | Limpieza y estadÃ­sticas              |
      | System Catalogs       | Metadatos (pg_class, pg_index, etc.) |
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

      ğŸ“Œ Regla DBA:
      
      Si no entiendes WAL y Autovacuum, tarde o temprano tendrÃ¡s problemas de rendimiento.
            </code>
      <code>
    </pre>

      Roles y Seguridad (mucho mÃ¡s que â€œusuariosâ€) <br>
      <pre>
      <code>
        En PostgreSQL NO existen usuarios, existen roles.
        
        Tipos de roles
        Roles de login â†’ personas / aplicaciones
        Roles sin login â†’ permisos

      </code>
    </pre>
      Ejemplos profesional : <br>
      <pre>
      <code>
        -- Rol base
        CREATE ROLE app_read;
        CREATE ROLE app_write;
        
        -- Usuario aplicaciÃ³n
        CREATE ROLE app_user
        LOGIN
        PASSWORD '********';
        
        -- AsignaciÃ³n
        GRANT app_read, app_write TO app_user;
        
        ğŸ“Œ Buenas prÃ¡cticas
        
        âŒ No usar postgres en aplicaciones
        âŒ No usar un solo usuario con todos los permisos
        
        âœ… Roles por responsabilidad
        âœ… Principio de mÃ­nimo privilegio        
      </code>
    </pre>
      PostgreSQL es 100% ACID : <br>
      <pre>
      <code>
      ğŸ”‘ Â¿QuÃ© es ACID?
      ACID son las siglas de cuatro propiedades fundamentales que garantizan la fiabilidad de las transacciones en una base de datos:
      
      Atomicity (Atomicidad)
      Una transacciÃ³n se ejecuta completa o no se ejecuta en absoluto.
      Ejemplo: si insertas un pedido y sus items, o se guardan todos o ninguno.
      PostgreSQL asegura esto con su sistema de transacciones y rollback.
      
      Consistency (Consistencia)
      DespuÃ©s de una transacciÃ³n, la base de datos siempre pasa de un estado vÃ¡lido a otro estado vÃ¡lido.
      Las reglas de integridad (constraints, foreign keys, triggers) garantizan que no queden datos corruptos.
      Ejemplo: no puedes tener un order_item que apunte a un order inexistente.
      
      Isolation (Aislamiento)
      Las transacciones concurrentes no interfieren entre sÃ­.
      PostgreSQL usa MVCC (Multi-Version Concurrency Control) para que cada transacciÃ³n vea una â€œfotoâ€ consistente de los datos, sin bloquearse innecesariamente.
      Ejemplo: dos usuarios pueden comprar productos al mismo tiempo sin pisarse los datos.
      
      Durability (Durabilidad)
      Una vez confirmada (commit) la transacciÃ³n, los datos quedan grabados de forma permanente, incluso si hay un fallo del sistema.
      PostgreSQL usa WAL (Write-Ahead Logging) para asegurar que los cambios se registren primero en un log antes de aplicarse, lo que permite recuperaciÃ³n tras fallos.        

      Ejemplo practico:
      
      BEGIN;
      
      INSERT INTO orders (...) VALUES (...);
      INSERT INTO order_items (...) VALUES (...);
      
      COMMIT;
      -- o
      ROLLBACK;

    </code>
    </pre>
      <strong>Relaciones y constraints (NO confÃ­es en la aplicaciÃ³n) </strong>
      <pre>
      <code>
        --ejemplo :

        CREATE TABLE sales.order (
            id BIGSERIAL PRIMARY KEY,
            client_id BIGINT NOT NULL,
            order_date DATE NOT NULL,
        
            CONSTRAINT fk_order_client
                FOREIGN KEY (client_id)
                REFERENCES sales.client(id)
        );

        ğŸ“Œ Reglas
        SIEMPRE usa FK
        SIEMPRE usa NOT NULL
        SIEMPRE valida con constraints

      </code>
    </pre>
    </article>

  </article>
    <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="prisma-install">prisma ORM</h2>
  <article>
    Empezamos instalando el prima: <br>
    <strong>1. Crear el proyecto NestJS</strong> <br>
    <pre>
      <code>
        npm i -g @nestjs/cli
        nest new api-backend
        cd api-backend
      </code>
        
    </pre>
    <strong>2. Instalamoas Prisma ORM en el proyecto</strong> <br>
    <pre>
      <code>
        npm install prisma @prisma/client
        npm install prisma --save-dev        
        npx prisma init
      </code>
    </pre>
    <strong>Nota</strong>: <br>
    Por defecto NestJS trabaja con PostgreSQL, pero si quieres cambiar de base de datos por ejemplo sqlite debes especificarlo asi: <br>
    <pre>
      <code>
         npx prisma init --datasource-provider sqlite
      </code>
    </pre>
    Esto crea:
    
    prisma/schema.prisma <br>
    .env <br><br>
    <strong>Nota</strong> <br>
    <pre>
      <code>
        si ejecutamos :
        npm install prisma -D
        en ves de :
        npm install prisma @prisma/client

      </code>
    </pre>
    el codigo recomendado segun las mejores practicas en <strong>schema.prisma</strong> es: <br>
    pero no se porque no lo genera asÃ­: <br>
    <pre>
      <code>
        generator client {
          provider = "prisma-client-js"
        }
        
        datasource db {
          provider = "postgresql"
          url      = env("DATABASE_URL")
        }
        
      </code>
    </pre>
      A partir de la version 7 esto cambia y la configuracion correcta es : <br>
      <pre>
        <code>
          generator client {
            provider     = "prisma-client"
            output       = "../src/generated/prisma"
            moduleFormat = "cjs"
          }
          
          datasource db {
            provider = "postgresql"
          }

        </code>
      </pre>
      Tambien ahora a partir de la version 7 aparece un archivo llamado <strong>prisma.config.ts</strong> que debe llevar lo siguiente: <br>
      <pre>
        <code>
          import "dotenv/config";
          import { defineConfig } from "prisma/config";
          
          export default defineConfig({
            schema: "prisma/schema.prisma",
            migrations: {
              path: "prisma/migrations",
            },
            datasource: {
              url: process.env["DATABASE_URL"],
            },
          });
          
          
        </code>
      </pre>
      <strong>Nota</strong> <br>
      la primera linea del import dotenv tuve que escribirla manual sin esa linea no reconoce la cadena de conexion que se guarda en <strong>.nev</strong> <br>
      
    <strong>3. Configurar conexiÃ³n a tu BD existente</strong> dentro de .env <br>
    <pre>
      <code>
        DATABASE_URL="postgresql://postgres:Clave01.@localhost:5432/supplier?schema=public"
        
      </code>
    </pre>
    <strong>4. Importar la estructura de tu base existente (sin borrar datos)</strong><br>
    <pre>
      <code>
    âš ï¸ IMPORTANTE: No uses <strong>prisma migrate dev</strong> porque eso puede alterar la BD.

    En su lugar usa:    
      npx prisma db pull  
      </code>
    </pre>
    instalamos e adapter de postgresql <br>
    <pre>
      <code>
        npm install @prisma/adapter-pg
        
      </code>
    </pre>
    podemos validar si la configuracion del prisma db pull esta correcto: <br>
    <pre>
      <code>
        npx prisma validate       
      </code>
    </pre>
    <strong>5. Generar el cliente Prisma</strong><br>
    <pre>
      <code>
        npx prisma generate
        
      </code>
    </pre>

    <strong>6. Crear mÃ³dulo Prisma en NestJS</strong><br>
    <pre>
      <code>
        nest g module prisma
        nest g service prisma
       
      </code>
    </pre>
    editamos prisma.service.ts <br>
    <pre>
      <code>
        import "dotenv/config";
        import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
        import { PrismaClient } from 'src/generated/prisma/client';
        import { PrismaPg } from '@prisma/adapter-pg';
        
        @Injectable()
        export class PrismaService extends PrismaClient implements OnModuleInit {
            constructor() {
                const adapter = new PrismaPg({ connectionString: process.env.DATABASE_URL });
                super({ adapter });
            }
            async onModuleInit() {
                try {
                    await this.$queryRaw`select 1`;
                    Logger.log(`Database Conection established`);
        
                } catch (error) {
                    Logger.error(`Conection failed`);
                    throw error;
                }
            }
        
        }
        
      </code>
    </pre>
    el codigo refactorizado de prisma.service.ts es : <br>
    <pre>
      <code>
        import "dotenv/config";
        import { Injectable, Logger, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
        import { PrismaClient, Prisma } from 'src/generated/prisma/client';
        import { PrismaPg } from '@prisma/adapter-pg';
        
        @Injectable()
        export class PrismaService
          extends PrismaClient
          implements OnModuleInit, OnModuleDestroy
        {
          private readonly logger = new Logger(PrismaService.name);
        
          constructor() {
            const databaseUrl = process.env.DATABASE_URL;
        
            if (!databaseUrl) {
              throw new Error('DATABASE_URL is not defined');
            }
        
            const adapter = new PrismaPg({ connectionString: databaseUrl });
        
            super({
              adapter,
              log: ['error', 'warn'],
            });
          }
        
          async onModuleInit(): Promise<void> {
            try {
              await this.$connect();
              this.logger.log('Database connection established');
            } catch (error) {
              this.logger.error('Database connection failed', error);
              throw error;
            }
          }
        
          async onModuleDestroy(): Promise<void> {
            await this.$disconnect();
            this.logger.log('Database connection closed');
          }
        }
        

        
      </code>
    </pre>

    <strong>nota</strong> <br>
    cuando agregue una tabla al schema y no se reflejaba en la base de datos me funciono escribiendo el comando :
    <pre>
      <code>
        npx prisma db push
        
      </code>
    </pre>
    
  </article>
  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="prisma-modelo">Prisma Modelo</h2>
  <article>
    estructura recomendada para un proyecto de nestJS + prisma 7 : <br>
    <pre>
      <code>
        src/
        â”‚
        â”‚
        â”œâ”€â”€ generated/
        â”‚   â”œâ”€â”€ prisma/
        â”‚       â”œâ”€â”€ schema.prisma.ts
        â”‚
        â”œâ”€â”€ prisma/
        â”‚   â”œâ”€â”€ prisma.module.ts
        â”‚   â”œâ”€â”€ prisma.service.ts
        â”œâ”€â”€ modules/
        â”‚   â”œâ”€â”€ county/
        â”‚   â”‚   â”œâ”€â”€ application/
        â”‚   â”‚   â”‚   â”œâ”€â”€ dto/
        â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ create-county.dto.ts
        â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ update-county.dto.ts
        â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ county-response.dto.ts
        â”‚   â”‚   â”‚   â””â”€â”€ county.service.ts
        â”‚   â”‚   â”œâ”€â”€ domain/
        â”‚   â”‚   â”‚   â””â”€â”€ county.entity.ts
        â”‚   â”‚   â”œâ”€â”€ infrastructure/
        â”‚   â”‚   â”‚   â”œâ”€â”€ prisma-county.repository.ts
        â”‚   â”‚   â”‚   â””â”€â”€ sql-county.repository.ts
        â”‚   â”‚   â”œâ”€â”€ presentation/
        â”‚   â”‚   â”‚   â””â”€â”€ county.controller.ts
        â”‚   â”‚   â””â”€â”€ county.module.ts
      </code>
    </pre>
    el modelo que se escribe dentro del <strong>schema.prisma.ts</strong> con el siguiente codigo: <br>
    <pre>
      <code>

        model prov {
          id    Int     @id @default(autoincrement())
          email String  @unique
          name  String?
        }
        
        model audit_log {
          id         Int      @id @default(autoincrement())
          user_id    Int?
          action     String   @db.VarChar(50)
          entity     String   @db.VarChar(100)
          entity_id  Int
          old_data   Json?
          new_data   Json?
          created_at DateTime @default(now()) @db.Timestamp(6)
          user       user?    @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
        }
        
        model county {
          id         Int        @id @default(autoincrement())
          state_id   Int
          name       String     @db.VarChar(40)
          code       String     @db.Char(3)
          created_at DateTime   @default(now()) @db.Timestamptz(6)
          updated_at DateTime   @default(now()) @db.Timestamptz(6)
          state      state      @relation(fields: [state_id], references: [id], map: "fk_county_state")
          customer   customer[]
        
          @@unique([state_id, name], map: "uq_county_name_per_state")
          @@index([state_id], map: "idx_county_state_id")
        }
        
        model customer {
          id               Int       @id @default(autoincrement())
          nit              String    @unique(map: "uq_customer_nit") @db.VarChar(20)
          first_name       String    @db.VarChar(50)
          middle_name      String?   @db.VarChar(50)
          last_name        String    @db.VarChar(50)
          second_last_name String?   @db.VarChar(50)
          email            String?   @unique(map: "uq_customer_email") @db.VarChar(120)
          phone            String?   @db.VarChar(30)
          address          String?   @db.VarChar(150)
          county_id        Int
          created_at       DateTime  @default(now()) @db.Timestamptz(6)
          updated_at       DateTime  @default(now()) @db.Timestamptz(6)
          county           county    @relation(fields: [county_id], references: [id], map: "fk_customer_county")
          invoice          invoice[]
        
          @@index([county_id], map: "idx_customer_county")
        }
        
        model invoice {
          id          Int      @id @default(autoincrement())
          customer_id Int
          total       Decimal  @db.Decimal(14, 2)
          status      String   @db.VarChar(20)
          created_by  Int
          created_at  DateTime @default(now()) @db.Timestamp(6)
          user        user     @relation(fields: [created_by], references: [id], onDelete: NoAction, onUpdate: NoAction)
          customer    customer @relation(fields: [customer_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
        }
        
        model permission {
          id              Int               @id @default(autoincrement())
          code            String            @unique @db.VarChar(100)
          description     String?
          created_at      DateTime          @default(now()) @db.Timestamp(6)
          role_permission role_permission[]
        }
        
        model role {
          id              Int               @id @default(autoincrement())
          name            String            @unique @db.VarChar(50)
          description     String?
          created_at      DateTime          @default(now()) @db.Timestamp(6)
          role_permission role_permission[]
          user_role       user_role[]
        }
        
        model role_permission {
          role_id       Int
          permission_id Int
          created_at    DateTime   @default(now()) @db.Timestamp(6)
          permission    permission @relation(fields: [permission_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
          role          role       @relation(fields: [role_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
        
          @@id([role_id, permission_id])
        }
        
        model state {
          id         Int      @id @default(autoincrement())
          name       String   @unique(map: "uq_state_name") @db.VarChar(40)
          code       String   @unique(map: "uq_state_code") @db.Char(2)
          created_at DateTime @default(now()) @db.Timestamp(6)
          updated_at DateTime @default(now()) @db.Timestamp(6)
          county     county[]
        
          @@index([name], map: "idx_state_name")
        }
        
        model user {
          id            Int         @id @default(autoincrement())
          username      String      @unique @db.VarChar(50)
          email         String      @unique @db.VarChar(150)
          password_hash String
          full_name     String      @db.VarChar(150)
          is_active     Boolean     @default(true)
          created_at    DateTime    @default(now()) @db.Timestamp(6)
          audit_log     audit_log[]
          invoice       invoice[]
          user_role     user_role[]
        }
        
        model user_role {
          user_id    Int
          role_id    Int
          created_at DateTime @default(now()) @db.Timestamp(6)
          role       role     @relation(fields: [role_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
          user       user     @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
        
          @@id([user_id, role_id])
        }
        
      </code>
    </pre>
    la consulta desde <strong>county.service.ts</strong> quedaria asÃ­:
    <pre>
      <code>
        async findAll() {
          return await this.prismaService.county.findMany({
            include: { state: true },
          });
        }
        
      </code>
    </pre>
    que generaria el siguiente endPoint <br>
    <pre>
      <code>
        [
          {
            "id": 1,
            "state_id": 1,
            "name": "MEDELLÃN",
            "code": "001",
            "created_at": "2025-11-11T16:11:45.288Z",
            "updated_at": "2025-11-11T16:11:45.288Z",
            "state": {
              "id": 1,
              "name": "ANTIOQUIA",
              "code": "05",
              "created_at": "2025-11-11T16:11:45.288Z",
              "updated_at": "2025-11-12T10:45:33.615Z"
            }
          },
          {
            "id": 2,
            "state_id": 1,
            "name": "ABEJORRAL",
            "code": "002",
            "created_at": "2025-11-11T16:11:45.288Z",
            "updated_at": "2025-11-11T16:11:45.288Z",
            "state": {
              "id": 1,
              "name": "ANTIOQUIA",
              "code": "05",
              "created_at": "2025-11-11T16:11:45.288Z",
              "updated_at": "2025-11-12T10:45:33.615Z"
            }
          },
        ]
        
      </code>
    </pre>
    que seria el equivalente en setencia sql : <br>
    <pre>
      <code>
        select c.id, c.name, s.name from county c left join state s on c.state_id = s.id ;
        
      </code>
    </pre>
  </article>

</body>

</html>