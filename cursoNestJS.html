<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Curso de NestJS Back End</title>
  <link rel="stylesheet" href="css/styles.css" />
</head>

<body>
  <h1>Curso de Nest JS  V11.0.14 </h1>
  <h2>Indice Tematico</h2>
  <ul>
    <li><a href="cursoNestJS.html#referencia">Referencias</a></li>
    <li><a href="cursoNestJS.html#instalacion">Instalacion iniciales</a></li>
    <li><a href="cursoNestJS.html#estructura">estructura </a></li>
    <li><a href="cursoNestJS.html#modulos">modulos </a></li>
    <li><a href="cursoNestJS.html#database">base de datos </a></li>
    <li><a href="cursoNestJS.html#convenciones">convenciones en base de datos </a></li>
    <li><a href="cursoNestJS.html#sgbd">Sistema de Gestin de Base de Datos (SGBD) </a></li>
  </ul>


  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="referencia">Referencias</h2>
  <article>
    pagina de documentacion oficial <a href="https://docs.nestjs.com/" target="_blank" rel="noopener noreferrer">NestJS</a> <br>
    curso de nestJS por Fazt <a href="https://www.youtube.com/watch?v=wsqcg5ZtUMM" target="_blank" rel="noopener noreferrer">curso por Fazt</a> <br>

  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="instalacion">Instalacion Inicial</h2>
  <article>
    empezaremos intalando el modulo a nivel general 
    <pre>
      <code>
         npm i -g @nestjs/cli
      </code>
    </pre>
    creamo el proyecto de NestJS llamado <strong>api-nest</strong>
    <pre>
      <code>
        nest new api-nest
      </code>
    </pre>
    entramo al proyecto, instalamos dependencias y ejecutamos el projecto
    <pre>
      <code>
        cd api-nest 
        npm install
        npm run start
      </code>
    </pre>
    en produccion se ejecuta con <strong>npm run start</strong> <br>
    pero en desarrollo se ejectua con <strong>npm run start:dev </strong> <br><br>

    Una vez instalado podemos ver los comando que nos permite trabajar, escribiendo <strong>nest</strong> <br>
    <strong>new n</strong> genera un nuevo projecto de nest <br>
    <strong>build</strong> compila nuestra aplicacion de nest <br>
    <strong>start</strong> ejecuta e inicializa nuestra aplicacion <br>
    <strong>info i</strong> muestra informacion <br>
    <strong>add</strong> adiciona una libreria al proyecto <br>
    <strong>generate g</strong> genera un nuevo elemento nest <br>

    <pre>
      <code>
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ name          â”‚ alias       â”‚ description                                  â”‚
        â”‚ application   â”‚ application â”‚ Generate a new application workspace         â”‚
        â”‚ class         â”‚ cl          â”‚ Generate a new class                         â”‚
        â”‚ configuration â”‚ config      â”‚ Generate a CLI configuration file            â”‚
        â”‚ controller    â”‚ co          â”‚ Generate a controller declaration            â”‚
        â”‚ decorator     â”‚ d           â”‚ Generate a custom decorator                  â”‚
        â”‚ filter        â”‚ f           â”‚ Generate a filter declaration                â”‚
        â”‚ gateway       â”‚ ga          â”‚ Generate a gateway declaration               â”‚
        â”‚ guard         â”‚ gu          â”‚ Generate a guard declaration                 â”‚
        â”‚ interceptor   â”‚ itc         â”‚ Generate an interceptor declaration          â”‚
        â”‚ interface     â”‚ itf         â”‚ Generate an interface                        â”‚
        â”‚ library       â”‚ lib         â”‚ Generate a new library within a monorepo     â”‚
        â”‚ middleware    â”‚ mi          â”‚ Generate a middleware declaration            â”‚
        â”‚ module        â”‚ mo          â”‚ Generate a module declaration                â”‚
        â”‚ pipe          â”‚ pi          â”‚ Generate a pipe declaration                  â”‚
        â”‚ provider      â”‚ pr          â”‚ Generate a provider declaration              â”‚
        â”‚ resolver      â”‚ r           â”‚ Generate a GraphQL resolver declaration      â”‚
        â”‚ resource      â”‚ res         â”‚ Generate a new CRUD resource                 â”‚
        â”‚ service       â”‚ s           â”‚ Generate a service declaration               â”‚
        â”‚ sub-app       â”‚ app         â”‚ Generate a new application within a monorepo â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

      </code>  
    </pre>  


  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="estructura">Estructura Inicial</h2>
  <article>
    Estructura inicial esta compueta por <strong>main.ts</strong>, y <strong>app.controller.ts, app.service.ts, app.module.ts</strong> con los 
    siguientes codigos : <br>
    <strong>main.ts</strong>
    <pre>
      <code>
        import { NestFactory } from '@nestjs/core';
        import { AppModule } from './app.module';
        
        async function bootstrap() {
          const app = await NestFactory.create(AppModule);
          await app.listen(process.env.PORT ?? 3000);
        }
        bootstrap();
        
      </code>
    </pre>
    <strong>app.module.ts</strong>
    <pre>
      <code>
        import { Module } from '@nestjs/common';
        import { AppController } from './app.controller';
        import { AppService } from './app.service';
        
        @Module({
          imports: [],
          controllers: [AppController],
          providers: [AppService],
        })
        export class AppModule {}

      </code>
    </pre>

    <strong>app.controller.ts</strong>
    <pre>
      <code>
        import { Controller, Get } from '@nestjs/common';
        import { AppService } from './app.service';
        
        @Controller()
        export class AppController {
          constructor(private readonly appService: AppService) {}
        
          @Get()
          getHello(): string {
            return this.appService.getHello();
          }
        }
        
      </code>
    </pre>
    <strong>app.service.ts</strong>
    <pre>
      <code>
        import { Injectable } from '@nestjs/common';
        
        @Injectable()
        export class AppService {
          getHello(): string {
            return 'Hello World! welcome NestJS';
          }
        }

      </code>
    </pre>
    <strong>Nota</strong> <br>
    si eliminamos el controller y el service y nos quedamos solamente con el module quedaria de la siguiente forma: <br>
    <pre>
      <code>
        import { Module } from '@nestjs/common';
        
        @Module({
          imports: [],
          controllers: [AppController],
          providers: [AppService],
        })
        export class AppModule {}

      </code>
    </pre>
    al ejecutarlo con <strong>npm run start:dev</strong> nos mostraria el siguiente error: <br>
    status: 404 porque no encuenta la pagina que debe ser llamanda desde el controlador. <br>

  </article>

    <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="modulos">modulos</h2>
  <article>
    Por convencion se recomienda que cada modulo exista en un carpeta idependiente en minuscula y en plural osea: <br>
    a excepcion de <strong>app</strong> que no debe estar en carpeta si en la parte externa de la aplicacion. <br>

    <pre>
      <code>
        users/
        orders/
        products/
        invoices/
        roles/
        permissions/

      </code>
    </pre>
    exception  en singular por ser modulos conceptuales y no representan <strong>CRUD</strong> de la aplicacion
    <pre>
      <code>
        auth/
        config/
        common/
        health/

      </code>
    </pre>
    empezaremos creando una subcarpeta <strong>tasks</strong> donde crearemos nuestro modulo de tareas. <br>
    dentro de la carpeta <strong>scr</strong> <br>
    ejecutamos el comando : <br>
    <pre>
      <code>
        
        $ nest generate --help
        Usage: nest generate|g [options] <schematic> [name] [path]
        
        Generate a Nest element.
          Schematics available on @nestjs/schematics collection:
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ name          â”‚ alias       â”‚ description                                  â”‚
            â”‚ application   â”‚ application â”‚ Generate a new application workspace         â”‚
            â”‚ class         â”‚ cl          â”‚ Generate a new class                         â”‚
            â”‚ configuration â”‚ config      â”‚ Generate a CLI configuration file            â”‚
            â”‚ controller    â”‚ co          â”‚ Generate a controller declaration            â”‚
            â”‚ decorator     â”‚ d           â”‚ Generate a custom decorator                  â”‚
            â”‚ filter        â”‚ f           â”‚ Generate a filter declaration                â”‚
            â”‚ gateway       â”‚ ga          â”‚ Generate a gateway declaration               â”‚
            â”‚ guard         â”‚ gu          â”‚ Generate a guard declaration                 â”‚
            â”‚ interceptor   â”‚ itc         â”‚ Generate an interceptor declaration          â”‚
            â”‚ interface     â”‚ itf         â”‚ Generate an interface                        â”‚
            â”‚ library       â”‚ lib         â”‚ Generate a new library within a monorepo     â”‚
            â”‚ middleware    â”‚ mi          â”‚ Generate a middleware declaration            â”‚
            â”‚ module        â”‚ mo          â”‚ Generate a module declaration                â”‚
            â”‚ pipe          â”‚ pi          â”‚ Generate a pipe declaration                  â”‚
            â”‚ provider      â”‚ pr          â”‚ Generate a provider declaration              â”‚
            â”‚ resolver      â”‚ r           â”‚ Generate a GraphQL resolver declaration      â”‚
            â”‚ resource      â”‚ res         â”‚ Generate a new CRUD resource                 â”‚
            â”‚ service       â”‚ s           â”‚ Generate a service declaration               â”‚
            â”‚ sub-app       â”‚ app         â”‚ Generate a new application within a monorepo â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        Options:
          -d, --dry-run                      Report actions that would be taken without writing out results.
          -p, --project [project]            Project in which to generate files.
          --flat                             Enforce flat structure of generated element.
          --no-flat                          Enforce that directories are generated.
          --spec                             Enforce spec files generation. (default: true)
          --spec-file-suffix [suffix]        Use a custom suffix for spec files.
          --skip-import                      Skip importing (default: false)
          --no-spec                          Disable spec files generation.
          -c, --collection [collectionName]  Schematics collection to use.
          -h, --help                         Output usage information.
      </code>
    </pre>
    el codigo de nuestro modulo quedaria: <br>
    <pre>
      <code>
        import { Module } from "@nestjs/common";
        
        @Module({})
        export class TaskModule{
        
        }        
      </code>
    </pre>
    ahora nuestro modulo TaskModule tenemos que importarlo desde app.module.ts : <br>
    <pre>
      <code>
        import { Module } from '@nestjs/common';
        import { AppController } from './app.controller';
        import { AppService } from './app.service';
        import { TaskModule } from './tasks/tasks.module';
        
        @Module({
          imports: [TaskModule],
          controllers: [AppController],
          providers: [AppService],
        })
        export class AppModule {}


      </code>
    </pre>
    por ejemplo si queremos crear un modulo <strong>project</strong> escribimos:
    <pre>
      <code>
        nest g mo project
      </code>
    </pre>
    y aumaticamente crea a carpeta <strong>project</strong> y crea project.module.ts, <tr>
    ademas dentro de app.module.ts import el modulo creado </tr>

  </article>



  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="database">base de datos</h2>
  <article>
    curso de base de datos Postgres en linux para analitica de datos <a href="https://www.youtube.com/watch?v=5no6nDBLjSc" target="_blank" rel="noopener noreferrer">postgres en linux por camilo suarez</a> <br>
    curso de base de datos por todoCoude <a href="https://www.youtube.com/watch?v=8N4M994IDt8" target="_blank" rel="noopener noreferrer">base de datos</a> <br>
    curso de base de datos por SergieCode <a href="https://www.youtube.com/watch?v=Fca_kWJJXvo" target="_blank" rel="noopener noreferrer">mysql, postgres, para BackEnd</a> 
  </article>

  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="convenciones">convenciones en base de datos</h2>
  <article>
    <strong>convenciones para nombre de tablas y columnas</strong> <br>
    <pre>
      <code>
        Nombres de tablas y columnas:
        
        Usa snake_case (ej: user_account, order_item).
        Siempre en singular para tablas que representan entidades (user, product).
        Evita abreviaturas poco claras.
        
        Esquemas:
        
        Usa esquemas para separar dominios (ej: auth.user, sales.order).
        MantÃ©n un esquema public solo para pruebas o datos comunes.
        Define permisos por esquema para mayor seguridad.
        
        Llaves primarias y forÃ¡neas:
        
        Usa id como PK con tipo BIGSERIAL o UUID.
        Nombra las FK con el patrÃ³n <tabla>_id (ej: user_id).
        
        Ãndices:
        
        Crea Ã­ndices en columnas usadas en WHERE, JOIN y ORDER BY.
        Usa Ã­ndices Ãºnicos para garantizar integridad.
        para los nombres se recomienda idx_<tabla>_<columnas>
        para FK constraints se recomienda fk_<tabla>_<referencia>
        unique se recomienda uq_<tabla>_<campo>
        
        Migraciones:
        Siempre versiona cambios en la base de datos.
        Documenta decisiones de diseÃ±o en cada migraciÃ³n.        

      </code>
    </pre>
    un ejemplo de las esctructura de una base de datos en postgres seria: <br>
    <pre>
      <code>
      </code>
      -- Esquema para autenticaciÃ³n y usuarios
      CREATE SCHEMA auth;
      
      CREATE TABLE auth.user (
          id BIGSERIAL PRIMARY KEY,
          email VARCHAR(255) UNIQUE NOT NULL,
          password_hash TEXT NOT NULL,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
      
      -- Esquema para catÃ¡logo de productos
      CREATE SCHEMA catalog;
      
      CREATE TABLE catalog.product (
          id BIGSERIAL PRIMARY KEY,
          name VARCHAR(150) NOT NULL,
          description TEXT,
          price NUMERIC(10,2) NOT NULL,
          stock INT DEFAULT 0,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
      
      -- Esquema para ventas
      CREATE SCHEMA sales;
      
      CREATE TABLE sales.order (
          id BIGSERIAL PRIMARY KEY,
          user_id BIGINT NOT NULL REFERENCES auth.user(id),
          total NUMERIC(10,2) NOT NULL,
          status VARCHAR(50) DEFAULT 'pending',
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
      
      CREATE TABLE sales.order_item (
          id BIGSERIAL PRIMARY KEY,
          order_id BIGINT NOT NULL REFERENCES sales.order(id),
          product_id BIGINT NOT NULL REFERENCES catalog.product(id),
          quantity INT NOT NULL,
          price NUMERIC(10,2) NOT NULL
      );
      
    </pre>
  <a href="cursoNestJS.html">â«</a>
  <hr />
  <h2 id="sgbd">SGBD Sistema de Gestion de Base de Datos</h2>
  <article>
    Primero que todo hay que entender que Postgres en un sistemas de gestion multi proceso no multihilo. <br>
    esto quiere de decir que el servidor esta escuchando y varios procesos estan corriendo solicitnao informacion, <br>
    como una pagina hecha con Next, o  un administrador de DB como DBeaver, etc. <br>
    por cada conexion se crea un servicio independiente para el sistema operativo, de tal forma que no interfiere unos con los otros, en cambio Mysql <br>
    maneja una sola conexion con multiples hilos (multi-thread). <br>
    ventajas de postgres, si un proceso falla no interfiere con los demas, en cambio en mysql si la conexion falla todos los procesos fallan, <br>
    es por eso que postgres nececita mas memoria que mysql. <br><br>
    <pre>
      <code>
        ğŸ’¡ Consejo de DBA: en aplicaciones modernas, para evitar saturar el servidor con demasiados procesos, 
        se recomienda usar un connection pooler como PgBouncer o Pgpool-II, que gestionan las conexiones de manera mÃ¡s eficiente.        
      </code>
    </pre>
    PostgreSQL es un motor cliente-servidor con arquitectura multi-proceso (no multi-thread).
    <pre>
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      | Componente            | FunciÃ³n                              |
      | --------------------- | ------------------------------------ |
      | Postmaster            | Proceso padre, gestiona conexiones   |
      | Backend process       | Un proceso por conexiÃ³n              |
      | Shared Buffers        | CachÃ© de datos en memoria            |
      | WAL (Write-Ahead Log) | Garantiza durabilidad                |
      | Autovacuum            | Limpieza y estadÃ­sticas              |
      | System Catalogs       | Metadatos (pg_class, pg_index, etc.) |
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

      ğŸ“Œ Regla DBA:
      
      Si no entiendes WAL y Autovacuum, tarde o temprano tendrÃ¡s problemas de rendimiento.
            </code>
      <code>
    </pre>
      
      Roles y Seguridad (mucho mÃ¡s que â€œusuariosâ€) <br>
    <pre>
      <code>
        En PostgreSQL NO existen usuarios, existen roles.
        
        Tipos de roles
        Roles de login â†’ personas / aplicaciones
        Roles sin login â†’ permisos

      </code>
    </pre>
    Ejemplos profesional : <br>
    <pre>
      <code>
        -- Rol base
        CREATE ROLE app_read;
        CREATE ROLE app_write;
        
        -- Usuario aplicaciÃ³n
        CREATE ROLE app_user
        LOGIN
        PASSWORD '********';
        
        -- AsignaciÃ³n
        GRANT app_read, app_write TO app_user;
        
        ğŸ“Œ Buenas prÃ¡cticas
        
        âŒ No usar postgres en aplicaciones
        âŒ No usar un solo usuario con todos los permisos
        
        âœ… Roles por responsabilidad
        âœ… Principio de mÃ­nimo privilegio        
      </code>
    </pre>
    PostgreSQL es 100% ACID : <br>
    <pre>
      <code>
      ğŸ”‘ Â¿QuÃ© es ACID?
      ACID son las siglas de cuatro propiedades fundamentales que garantizan la fiabilidad de las transacciones en una base de datos:
      
      Atomicity (Atomicidad)
      Una transacciÃ³n se ejecuta completa o no se ejecuta en absoluto.
      Ejemplo: si insertas un pedido y sus items, o se guardan todos o ninguno.
      PostgreSQL asegura esto con su sistema de transacciones y rollback.
      
      Consistency (Consistencia)
      DespuÃ©s de una transacciÃ³n, la base de datos siempre pasa de un estado vÃ¡lido a otro estado vÃ¡lido.
      Las reglas de integridad (constraints, foreign keys, triggers) garantizan que no queden datos corruptos.
      Ejemplo: no puedes tener un order_item que apunte a un order inexistente.
      
      Isolation (Aislamiento)
      Las transacciones concurrentes no interfieren entre sÃ­.
      PostgreSQL usa MVCC (Multi-Version Concurrency Control) para que cada transacciÃ³n vea una â€œfotoâ€ consistente de los datos, sin bloquearse innecesariamente.
      Ejemplo: dos usuarios pueden comprar productos al mismo tiempo sin pisarse los datos.
      
      Durability (Durabilidad)
      Una vez confirmada (commit) la transacciÃ³n, los datos quedan grabados de forma permanente, incluso si hay un fallo del sistema.
      PostgreSQL usa WAL (Write-Ahead Logging) para asegurar que los cambios se registren primero en un log antes de aplicarse, lo que permite recuperaciÃ³n tras fallos.        

      Ejemplo practico:
      
      BEGIN;
      
      INSERT INTO orders (...) VALUES (...);
      INSERT INTO order_items (...) VALUES (...);
      
      COMMIT;
      -- o
      ROLLBACK;

    </code>
    </pre>
    <strong>Relaciones y constraints (NO confÃ­es en la aplicaciÃ³n) </strong>
    <pre>
      <code>
        --ejemplo :

        CREATE TABLE sales.order (
            id BIGSERIAL PRIMARY KEY,
            client_id BIGINT NOT NULL,
            order_date DATE NOT NULL,
        
            CONSTRAINT fk_order_client
                FOREIGN KEY (client_id)
                REFERENCES sales.client(id)
        );

        ğŸ“Œ Reglas
        SIEMPRE usa FK
        SIEMPRE usa NOT NULL
        SIEMPRE valida con constraints

      </code>
    </pre>
  </article>

  </article>

</body>
</html>